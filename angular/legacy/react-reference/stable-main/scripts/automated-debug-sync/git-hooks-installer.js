#!/usr/bin/env node

/**
 * ü™ù GIT HOOKS INSTALLER FOR DEBUGGING TOOL AUTOMATION
 * 
 * Sets up Git hooks to automatically maintain debugging tools when
 * interfaces or critical code changes.
 * 
 * HOOKS INSTALLED:
 * - pre-commit: Check if debugging tools need updates before commit
 * - post-merge: Update debugging tools after pulling changes
 * - pre-push: Validate debugging tools are current before pushing
 * 
 * TRIGGERS:
 * - Interface changes (useAppState.ts, usePersistence.ts, types.ts)
 * - Business logic changes (calcs.ts, calculations.ts)
 * - Component changes (WizardShell.tsx)
 */

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import { execSync } from 'child_process'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const rootDir = path.resolve(__dirname, '../..')
const hooksDir = path.join(rootDir, '.git/hooks')

console.log('ü™ù GIT HOOKS INSTALLER FOR DEBUGGING TOOL AUTOMATION')
console.log('===================================================\n')

class GitHooksInstaller {
  constructor() {
    this.hooksToInstall = [
      {
        name: 'pre-commit',
        purpose: 'Check debugging tools before commit',
        script: this.generatePreCommitHook()
      },
      {
        name: 'post-merge', 
        purpose: 'Update debugging tools after merge/pull',
        script: this.generatePostMergeHook()
      },
      {
        name: 'pre-push',
        purpose: 'Validate debugging tools before push',
        script: this.generatePrePushHook()
      }
    ]
  }

  // Generate pre-commit hook
  generatePreCommitHook() {
    return `#!/bin/sh
#
# ü™ù PRE-COMMIT HOOK: Debug Tool Synchronization
# Generated by git-hooks-installer.js
#
# Checks if debugging tools need updates when critical files change
#

echo "üîç Checking if debugging tools need updates..."

# Files that trigger debugging tool updates
WATCHED_FILES="src/hooks/useAppState.ts src/hooks/usePersistence.ts src/components/Wizard/types.ts"

# Check if any watched files are being committed
CHANGED_FILES=$(git diff --cached --name-only)
NEEDS_UPDATE=false

for file in $WATCHED_FILES; do
  if echo "$CHANGED_FILES" | grep -q "$file"; then
    echo "‚ö†Ô∏è  Interface file modified: $file"
    NEEDS_UPDATE=true
  fi
done

if [ "$NEEDS_UPDATE" = true ]; then
  echo ""
  echo "ü§ñ Running automated debugging tool updates..."
  
  # Run field mapping generator
  node scripts/automated-debug-sync/field-mapping-generator.js
  
  # Check if updates are needed
  if [ -f "scripts/automated-debug-sync/debugging-tool-updates.md" ]; then
    echo ""
    echo "üìã Debugging tool updates available!"
    echo "Run: node scripts/automated-debug-sync/update-all-tools.js"
    echo ""
    echo "‚ö†Ô∏è  Consider running this before committing to keep tools synchronized"
    echo ""
    echo "To skip this check: git commit --no-verify"
    
    # Don't block commit, just warn
    # exit 1  # Uncomment to block commits until tools are updated
  fi
fi

echo "‚úÖ Pre-commit debugging tool check complete"
exit 0
`
  }

  // Generate post-merge hook
  generatePostMergeHook() {
    return `#!/bin/sh
#
# ü™ù POST-MERGE HOOK: Debug Tool Updates
# Generated by git-hooks-installer.js
#
# Automatically updates debugging tools after merge/pull
#

echo "üîÑ Post-merge: Checking for debugging tool updates..."

# Check if any interface files were modified in the merge
MODIFIED_FILES=$(git diff-tree -r --name-only HEAD@{1} HEAD)

INTERFACE_MODIFIED=false
for file in src/hooks/useAppState.ts src/hooks/usePersistence.ts src/components/Wizard/types.ts; do
  if echo "$MODIFIED_FILES" | grep -q "$file"; then
    echo "üîç Interface file modified in merge: $file"
    INTERFACE_MODIFIED=true
  fi
done

if [ "$INTERFACE_MODIFIED" = true ]; then
  echo ""
  echo "ü§ñ Auto-updating debugging tools..."
  
  # Run the automated updater
  node scripts/automated-debug-sync/field-mapping-generator.js
  
  if [ -f "scripts/automated-debug-sync/update-all-tools.js" ]; then
    node scripts/automated-debug-sync/update-all-tools.js
    echo "‚úÖ Debugging tools updated automatically"
  fi
else
  echo "‚úÖ No interface changes detected - debugging tools current"
fi

exit 0
`
  }

  // Generate pre-push hook
  generatePrePushHook() {
    return `#!/bin/sh
#
# ü™ù PRE-PUSH HOOK: Debug Tool Validation
# Generated by git-hooks-installer.js
#
# Validates debugging tools are current before pushing
#

echo "üîç Pre-push: Validating debugging tool status..."

# Run registry health check
node scripts/automated-debug-sync/debug-tool-registry.js --health > /tmp/debug-health.log 2>&1

if grep -q "broken\\|missing" /tmp/debug-health.log; then
  echo ""
  echo "‚ùå PUSH BLOCKED: Debugging tools have issues"
  echo ""
  cat /tmp/debug-health.log
  echo ""
  echo "üîß Fix debugging tools before pushing:"
  echo "   node scripts/automated-debug-sync/update-all-tools.js"
  echo ""
  echo "To skip validation: git push --no-verify"
  
  rm -f /tmp/debug-health.log
  exit 1
fi

if grep -q "outdated" /tmp/debug-health.log; then
  echo ""
  echo "‚ö†Ô∏è  WARNING: Some debugging tools are outdated"
  echo "Consider updating: node scripts/automated-debug-sync/update-all-tools.js"
  echo ""
fi

rm -f /tmp/debug-health.log
echo "‚úÖ Debugging tools validated - ready to push"
exit 0
`
  }

  // Install a single hook
  installHook(hook) {
    const hookPath = path.join(hooksDir, hook.name)
    const backupPath = hookPath + '.backup'

    console.log(`üîß Installing ${hook.name} hook...`)

    // Backup existing hook if it exists
    if (fs.existsSync(hookPath)) {
      console.log(`   üì¶ Backing up existing hook to ${hook.name}.backup`)
      fs.copyFileSync(hookPath, backupPath)
    }

    // Write new hook
    fs.writeFileSync(hookPath, hook.script)
    
    // Make executable
    fs.chmodSync(hookPath, '755')
    
    console.log(`   ‚úÖ ${hook.name} hook installed`)
    console.log(`   üìã Purpose: ${hook.purpose}`)
  }

  // Install all hooks
  installAllHooks() {
    // Check if .git directory exists
    if (!fs.existsSync(path.join(rootDir, '.git'))) {
      console.log('‚ùå Not a git repository - cannot install hooks')
      return false
    }

    // Create hooks directory if it doesn't exist
    if (!fs.existsSync(hooksDir)) {
      fs.mkdirSync(hooksDir, { recursive: true })
      console.log('üìÅ Created .git/hooks directory')
    }

    console.log(`üìç Installing hooks to: ${hooksDir}\n`)

    // Install each hook
    this.hooksToInstall.forEach(hook => {
      this.installHook(hook)
    })

    console.log('\n‚úÖ All Git hooks installed successfully!')
    return true
  }

  // Generate configuration for the hooks
  generateHookConfig() {
    const configPath = path.join(__dirname, 'git-hooks-config.json')
    
    const config = {
      version: "1.0.0",
      installedAt: new Date().toISOString(),
      hooks: this.hooksToInstall.map(hook => ({
        name: hook.name,
        purpose: hook.purpose,
        enabled: true
      })),
      watchedFiles: [
        "src/hooks/useAppState.ts",
        "src/hooks/usePersistence.ts", 
        "src/components/Wizard/types.ts",
        "src/lib/calcs.ts",
        "src/components/Wizard/calculations.ts"
      ],
      settings: {
        blockCommitsOnOutdatedTools: false, // Set to true for strict mode
        autoUpdateAfterMerge: true,
        validateOnPush: true
      }
    }

    fs.writeFileSync(configPath, JSON.stringify(config, null, 2))
    console.log(`\nüìã Hook configuration saved: ${configPath}`)
  }

  // Uninstall hooks
  uninstallHooks() {
    console.log('üóëÔ∏è  Uninstalling Git hooks...')

    this.hooksToInstall.forEach(hook => {
      const hookPath = path.join(hooksDir, hook.name)
      const backupPath = hookPath + '.backup'

      if (fs.existsSync(hookPath)) {
        console.log(`   üóëÔ∏è  Removing ${hook.name} hook`)
        fs.unlinkSync(hookPath)

        // Restore backup if it exists
        if (fs.existsSync(backupPath)) {
          console.log(`   üîÑ Restoring backup for ${hook.name}`)
          fs.copyFileSync(backupPath, hookPath)
          fs.unlinkSync(backupPath)
        }
      }
    })

    console.log('‚úÖ Git hooks uninstalled')
  }

  // Test hooks
  testHooks() {
    console.log('üß™ Testing Git hooks...')

    this.hooksToInstall.forEach(hook => {
      const hookPath = path.join(hooksDir, hook.name)
      
      if (fs.existsSync(hookPath)) {
        console.log(`   üß™ Testing ${hook.name}...`)
        try {
          // Test that the hook is executable and has no syntax errors
          execSync(`bash -n "${hookPath}"`, { stdio: 'pipe' })
          console.log(`   ‚úÖ ${hook.name} syntax OK`)
        } catch (error) {
          console.log(`   ‚ùå ${hook.name} has syntax errors`)
        }
      } else {
        console.log(`   ‚ùì ${hook.name} not found`)
      }
    })
  }

  // Main execution
  run(action = 'install') {
    console.log('üöÄ Starting Git hooks setup...\n')

    switch (action) {
      case 'install':
        const success = this.installAllHooks()
        if (success) {
          this.generateHookConfig()
          console.log('\nüéâ Git hooks setup complete!')
          console.log('\nüìã What happens now:')
          console.log('   ‚Ä¢ pre-commit: Checks debugging tools before commits')
          console.log('   ‚Ä¢ post-merge: Auto-updates tools after merge/pull')  
          console.log('   ‚Ä¢ pre-push: Validates tools before push')
        }
        break

      case 'uninstall':
        this.uninstallHooks()
        break

      case 'test':
        this.testHooks()
        break

      default:
        console.log('Usage: node git-hooks-installer.js [install|uninstall|test]')
    }
  }
}

// CLI interface
const action = process.argv[2] || 'install'
const installer = new GitHooksInstaller()
installer.run(action)
